## Классовое наследование

>"В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы)."

В ES6 представили новый синтаксис для классов. Здесь стоит отметить, что класс ES6 не представляет собой новую объектно-ориентированную модель наследования. ~~Это просто синтаксический сахар для существующего в JavaScript прототипного наследования.~~


~~Класс в ES6 представляет собой просто новый синтаксис для работы с прототипами и функциями-конструкторами, которые мы привыкли использовать в ES5.~~

### Почему классы называют синтаксическим сахаром
Синтаксический сахар — это упрощенный или более удобный синтаксис для реализации, которая в основе использует существующие механизмы языка, не добавляя принципиально новой функциональности. Классы в JavaScript соответствуют этому определению по следующим причинам:

1) #### Прототипная основа остается неизменной:
- Классы в JavaScript — это синтаксическая обертка над функциями-конструкторами и прототипным наследованием. Под капотом они используют те же механизмы цепочки прототипов.
- Пример эквивалентности:
``` js
// Класс
class Animal1 {
  constructor(name) {
    this.name = name;
  }
  say() {
    console.log(`${this.name} гудит`);
  }
}

// Эквивалент без классов
function Animal2(name) {
  this.name = name;
}
Animal2.prototype.say = function() {
  console.log(`${this.name} издает звуки`);
};

const animal1 = new Animal1("Cat");
const animal2 = new Animal2("Dog");
console.log(animal1, animal2);

animal1.say();
animal2.say();
```
- Класс Animal создает функцию-конструктор, а методы класса добавляются в Animal.prototype.

2) ### Наследование работает через прототипы:
- Ключевое слово `extends` в классах реализует наследование через установку прототипа дочернего конструктора на прототип родительского, аналогично `Object.create()` или другим приемам прототипного наследования.
```js
class Dog1 extends Animal1 {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }
  say() {
    console.log(`${this.name} лает! Порода: ${this.breed}`);
  }
}

// Эквивалент без классов
function Dog2(name, breed) {
  Animal2.call(this, name);
  this.breed = breed;
}
Dog2.prototype = Object.create(Animal2.prototype);
Dog2.prototype.constructor = Dog2;
Dog2.prototype.say = function() {
  console.log(`${this.name} лает! Порода: ${this.breed}`);
};

const dog1 = new Dog1('Тузик', 'тварь');
const dog2 = new Dog2('Бобик', 'тварь');
console.log(dog1, dog2);
dog1.say();
dog2.say();
```
- `super` заменяет вызов родительского конструктора через `Parent.call(this, ...)`.

3) ### Методы и свойства в прототипе:
- Методы, определенные в классе, автоматически добавляются в `prototype` конструктора, как и в случае ручного задания `Dog2.prototype.say`.
- Статические методы (`static`) эквивалентны свойствам, добавленным напрямую в функцию-конструктор.

4) ### Нет новой модели наследования:
- Классы не вводят новую модель, отличную от прототипной. Они лишь упрощают синтаксис для создания конструкторов, прототипов и наследования.

### Почему классы могут не считаться ***только*** синтаксическим сахаром
Хотя классы в основном являются оберткой над прототипным наследованием, есть несколько аспектов, которые добавляют уникальное поведение или ограничения, из-за чего некоторые разработчики могут утверждать, что классы — это нечто большее, чем просто синтаксический сахар:

1) ### Строгие ограничения и семантика:
- Классы вводят более строгую семантику, которая не всегда воспроизводится в чистом прототипном подходе:
  - Обязательный вызов `new`: Попытка вызвать класс как обычную функцию (`Class()`) вызывает ошибку, в отличие от функций-конструкторов.
  ```js
  class Animal1 {}
  Animal1(); // TypeError: Class constructor Animal cannot be invoked without 'new'
  function Animal2() {}
  Anima2(); // Работает!!!
  ```
  - Невозможность изменения `prototype` во время выполнения: В классах прототип фиксируется, и попытка переопределить `Class.prototype` для экземпляров приводит к ошибкам в некоторых случаях.
  - Обязательный вызов `super` в конструкторе дочернего класса: Без `super` в `constructor` дочернего класса будет ошибка, что добавляет дополнительное правило, отсутствующее в прототипном подходе.

2) ### Поддержка приватных полей (с ES2022):
- Классы ввели приватные поля (с `#`), которые обеспечивают настоящую инкапсуляцию, недоступную в обычном прототипном наследовании без замыканий.
```js
class Counter {
  #count = 0;
  increment() {
    return ++this.#count;
  }
}
const counter = new Counter();
console.log(counter.#count); // SyntaxError
```

3) ### Семантическая ясность и читаемость:
- Классы ориентированы на разработчиков, знакомых с ООП в других языках (Java, C++), и делают код более понятным для них. Это не просто синтаксис, а способ структурирования кода, который влияет на архитектуру программы.
- Например, `extends` и `super` делают наследование более декларативным и менее подверженным ошибкам, чем ручная настройка `Object.create()` и `call`.

4) ### Некоторые оптимизации движка:
- Современные JavaScript-движки (например, V8) могут оптимизировать код с классами иначе, чем с функциями-конструкторами, из-за их предсказуемой структуры. Хотя это не меняет семантику, производительность может отличаться.
---

### Статические свойства и методы
Мы также можем присвоить метод самому классу. Такие методы называются статическими.
> Статические свойства и методы в JavaScript — это свойства и методы, которые принадлежат непосредственно классу (или функции-конструктору), а не его экземплярам. Они не зависят от конкретного объекта, созданного с помощью `new`, и обычно используются для функциональности, связанной с классом в целом, а не с отдельными его экземплярами.

Статические свойства и методы наследуются дочерними классами через цепочку прототипов конструкторов.

В объявление класса они добавляются с помощью ключевого слова `static`, например:
```js
class MathUtils {
  static PI = 3.14159;
  static square(number) {
    return number * number;
  }
}

console.log(MathUtils.PI);
console.log(MathUtils.square(5));
```
Статические свойства также могут быть приватными с использованием #:
```js
class Counter {
  static #instanceCount = 0;

  constructor() {
    Counter.#instanceCount++;
  }

  static getInstanceCount() {
    return Counter.#instanceCount;
  }
}

const c1 = new Counter();
const c2 = new Counter();
console.log(Counter.getInstanceCount()); // 2
```

#### Зачем используются статические свойства и методы
Статические члены полезны в ситуациях, когда функциональность или данные связаны с классом в целом, а не с конкретными его экземплярами. Вот основные сценарии их использования:

1) Статические члены полезны в ситуациях, когда функциональность или данные связаны с классом в целом, а не с конкретными его экземплярами. Вот основные сценарии их использования:
    - Статические методы часто используются для создания утилитных функций, которые выполняют общие операции, не требующие состояния экземпляра.
    - Пример: `Math` в JavaScript (`Math.sqrt()`, `Math.random()`) — это объект с утилитными статическими методами.
2) Константы и конфигурации:
    - Статические свойства удобно использовать для хранения констант или настроек, общих для всех экземпляров класса.
    ```js
    class Database {
      static URL = "https://api.example.com";
      static connect() {
        console.log(`Connecting to ${Database.URL}`);
      }
    }
    Database.connect();
    ```
3) Фабричные методы:
    - Статические методы часто используются для создания экземпляров класса с определенной логикой (альтернатива конструктору).
    ```js
    class User {
      constructor(name, role) {
        this.name = name;
        this.role = role;
      }
      static createAdmin(name) {
        return new User(name, "admin");
      }
    }
    const admin = User.createAdmin("Alice");
    console.log(admin);
    ```
4) Отслеживание состояния класса:
    - Статические свойства могут использоваться для хранения данных, общих для всех экземпляров, например, для подсчета созданных объектов.
    ```js
    class Item {
      static #count = 0;
      constructor() {
        Item.#count++;
      }
      static getCount() {
        return Item.#count;
      }
    }
    new Item();
    new Item();
    console.log(Item.getCount()); //2
    ```
5) Кэширование или глобальные ресурсы:
    - Статические свойства могут хранить кэш или общие ресурсы, доступные для всех экземпляров.
    ```js
    class Cache {
      static #data = new Map();
      static set(key, value) {
        Cache.#data.set(key, value);
      }
      static get(key) {
        return Cache.#data.get(key);
      }
    }
    Cache.set("user", { name: "Bob" });
    console.log(Cache.get("user")); // { name: "Bob" }
    ```

---
### 
### Наследование от Hero
```js
export class Hero {
  #health = 50;
  constructor(params) {
    this.name = params.name;
    this.#health = params.health;
    this.damage = params.damage;
  }
  isAlive() {
    return this.#health > 0;
  }
  get health() {
    return this.#health;
  }
  set health(value) {
    if (value <= 0) {
      console.log(`${this.name} убит!`);
    }
    this._health = Math.max(0, value);
  }
  attack() {
    if (this.isAlive()) {
      console.log(`${this.name} атакует и наносит ${this.damage} урона!`);
    } else {
      console.log(`${this.name} мертв!`);
    }
  }
}

export class Assassin extends Hero {
  #isHidden = false;
  constructor(params) {
    super({ name: "Assassin", health: params.health, damage: params.damage });
  }
  hide() {
    this.#isHidden = true;
  }
  attack() {
    if (this.isAlive()) {
      console.log(
        `${this.name} проводит ${
          this.#isHidden ? "скрытную " : ""
        }атаку и наносит ${
          this.#isHidden ? this.damage * 1.5 : this.damage
        } урона!`
      );
    } else {
      console.log(`${this.name} мертв!`);
    }
  }
}

```