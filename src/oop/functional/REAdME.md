## Функциональное наследование

### Наследование от Hero

```js
export function Hero(params) {
  let _health = Math.max(1, params.health);
  this.name = params.name;
  this.damage = params.damage;

  this.isAlive = () => _health > 0;

  Object.defineProperty(this, "health", {
    get: function () {
      return _health;
    },
    set: function (value) {
      if (value <= 0) {
        this.isAlive = false;
        console.log(`${this.name} убит!`);
      }
      _health = Math.max(0, value);
    },
  });
  this.attack = function () {
    if (this.isAlive) {
      console.log(`${this.name} атакует и наносит ${this.damage} урона!`);
    } else {
      console.log(`${this.name} мертв!`);
    }
  };
}

export function Assassin(params) {
  Hero.apply(this, arguments);

  this.name = "Assassin";
  this._isHidden = false;

  this.hide = function() {
    this._isHidden = true;
  };

  this.attack = function () {
    console.log(
      `${this.name} проводит ${this._isHidden ? 'скрытную ' : ''}атаку и наносит ${
        this._isHidden ? this.damage * 1.5 : this.damage
      } урона!`
    );
  };
}

```

Когда функция `Assassin` вызывается через `new Assassin(params)` происходит:
1. Создается новый пустой объект, и он присваивается `this`
2. Выполняется тело функции(обычно оно модифицирует `this`, добавляя туда новые поля и функции).
3. Возвращается значение `this`(неявно).

Функциональное наследование без прототипов предполагает, что дочерний объект не наследует свойства и методы от родительского через цепочку прототипов. Вместо этого дочерний объект напрямую получает все свойства и методы родителя, передаваемые через вызов конструктора родительского объекта (`Hero.call`()) или `Hero.apply()`).

При функциональном наследовании:
- Нет доступа к цепочке прототипов
- Нет доступа к методам родителя через `this.__proto__`, как при наследовании через прототипы.

### Преимущества:
- **Явное наследование**: все свойства и методы родителя явно копируются в дочерний объект.
- **Инкапсуляция приватных данных через замыкания**
- **Никаких неожиданных побочных эффектов**: так как нет прототипов, то мы избегаем неожиданных побочных эффектов, когда изменение одного объекта влияет на другие через цепочку прототипов.

### Недостатки:
- **Отсутствие разделения состояния**: каждый объект, созданный через функциональное наследование, имеет свои собственные копии свойств и методов, унаследованных от родителя. Это может привести к дублированию данных и увеличению потребления памяти. В случае использования прототипов все экземпляры одного класса будут использовать одни и те же методы, что может быть более эффективно.
- **Отсутствие наследования по прототипу**: методы, добавленные в родителя после создания дочернего объекта, не будут доступны дочерним.