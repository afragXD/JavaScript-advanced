# ES2015

## Содержание
### [1)let, const и блочная область видимости](#1-let-const-и-блочная-область-видимости)
### [2)Стрелочные функции](#2-стрелочные-функции)
### [3)Параметры по умолчанию](#3-параметры-по-умолчанию)
### [4)Spread/Rest](#4-spread--rest-оператор)
### [5)Расширение возможностей литералов объекта](#5-расширение-возможностей-литералов-объекта)
### [6)Восьмеричный и двоичный литералы](#6-восьмеричный-и-двоичный-литералынужно-ли-нам-это)
### [7)Деструктуризация массивов и объектов](#7-деструктуризация-массивов-и-объектов)
### [8)Ключевое слово super для объектов](#8-ключевое-слово-super-для-объектов)
### [9)Шаблонные строки](#9-шаблонные-строки)
### [10)for...of и for...in](#10-forof-и-forin)
### [11)Map и WeakMap](#11-map-и-weakmap)
### [12)Set и WeakSet](#12-set-и-weakset)
### [13)Классы](#13-классы)
### [14)Тип данных Symbol](#14-тип-данных-symbol)
### [15)Итераторы](#15-итераторы)
### [16)Генераторы](#16-генераторы)
### [17)Промисы](#17-промисы)

---

## 1) let, const и блочная область видимости
Ключевое слово `let` позволяет объявлять переменные с ограниченной областью видимости — только для блока {...}, в котором происходит объявление. Это называется блочной областью видимости. Вместо ключевого слова `var`, которое обеспечивает область видимости внутри функции, стандарт ES6 рекомендует использовать `let`.

Другой формой объявления переменной с блочной областью видимости является ключевое слово const. Оно предназначено для объявления переменных (констант), значения которых доступны только для чтения. Это означает не то, что значение константы неизменно, а то, что идентификатор переменной не может быть переприсвоен.

О чём стоит помнить:


- Когда дело касается поднятия переменных (hoisting) `let` и `const`, их поведение отличается от традиционного поведения `var` и `function`. И `let` и `const` не существуют до своего объявления.
- Областью видимости `let` и `const` является ближайший блок.
- При использовании `const` рекомендуется использовать ПРОПИСНЫЕ_БУКВЫ.
- В const одновременно с объявлением переменной должно быть присвоено значение.
---
## 2) Стрелочные функции
Стрелочные функции представляют собой сокращённую запись функций в ES6. Стрелочная функция состоит из списка параметров `( ... )`, за которым следует знак `=>` и тело функции.

```js
// Классическое функциональное выражение
let addition = function(a, b) {
    return a + b;
};

// Стрелочная функция
let addition = (a, b) => a + b;
```
Заметим, что в примере выше, тело функции представляет собой краткую запись, в которой не требуется явного указания на то, что мы хотим вернуть результат.

Стрелочные функции не просто делают код короче. Они тесно связаны с ключевым словом `this` и привязкой контекста.

Поведение стрелочных функций с ключевым словом `this` отличается от поведения обычных функций с `this`. Каждая функция в JavaScript определяет свой собственный контекст `this`, но внутри стрелочных функций значение `this` то же самое, что и снаружи (стрелочные функции не имеют своего `this`) и определяется в момент создания функции.

---

## 3) Параметры по умолчанию
ES6 позволяет установить параметры по умолчанию при объявлении функции. Вот простой пример:

```js
let getFinalPrice = (price, tax = 0.7) => price + price * tax;
getFinalPrice(500); // 850, так как значение tax не задано

getFinalPrice(500, 0.2); // 600, значение tax по-умолчанию заменяется на 0.2
```

---

## 4) Spread / Rest оператор
`...` оператор называют как spread или rest, в зависимости от того, как и где он используется.


При использовании в любом итерируемом объекте (iterable), данный оператор "разбивает" ("spread") его на индивидуальные элементы:
```js
function foo(x, y, z) {
    console.log(x, y, z);
}

let arr = [1, 2, 3];
foo(...arr); // 1 2 3
```

Другим распространённым использованием оператора `...` является объединение набора значений в один массив. В данном случае оператор Spread "собирает" элементы в массив.
```js
function foo(...args) {
    console.log(args);
}
foo(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
```

---

## 5) Расширение возможностей литералов объекта
ES6 позволяет объявить литералы объекта с помощью короткого синтаксиса для инициализации свойств из переменных и определения функциональных методов. Также, стандарт обеспечивает возможность вычисления свойств непосредственно в литерале объекта и использовать короткую запись метода объекта.
```js
function getCar(make, model, value) {
    return {
        // с синтаксисом короткой записи можно
        // пропускать значение свойства, если оно
        // совпадает с именем переменной, значение
        // которой мы хотим использовать
        make,  // аналогично make: make
        model, // аналогично model: model
        value, // аналогично value: value

        // вычисляемые свойства теперь работают в
        // литералах объекта
        ['make' + make]: true,

        // Короткая запись метода объекта пропускает
        // ключевое слово `function` и двоеточие. Вместо
        // "depreciate: function() {}" можно написать:
        depreciate() {
            this.value -= 2500;
        }
    };
}

let car = getCar('Kia', 'Sorento', 40000);
console.log(car);
// {
//     make: 'Kia',
//     model:'Sorento',
//     value: 40000,
//     makeKia: true,
//     depreciate: function()
// }
```

---

## 6) Восьмеричный и двоичный литералы(нужно ли нам это?)
В ES6 появилась новая поддержка для восьмеричных и двоичных литералов.
Добавление к началу числа `0o` или `0O` преобразует его в восьмеричную систему счисления (аналогично, `0b` или `0B` преобразует в двоичную систему счисления). Посмотрим на следующий код:
```js
let oValue = 0o10;
console.log(oValue); // 8

let bValue = 0b10;
console.log(bValue); // 2
```

---

## 7) Деструктуризация массивов и объектов
Деструктуризация помогает избежать использования вспомогательных переменных при взаимодействии с объектами и массивами.

```js
function foo() {
    return [1, 2, 3];
}
let arr = foo(); // [1,2,3]

let [a, b, c] = foo();
console.log(a, b, c); // 1 2 3

function bar() {
    return {
        x: 4,
        y: 5,
        z: 6
    };
}
let { x: a, y: b, z: c } = bar();
console.log(a, b, c); // 4 5 6
```

---

## 8) Ключевое слово super для объектов
ES6 позволяет использовать метод `super` в (безклассовых) объектах с прототипами. Вот простой пример:

```js
var parent = {
    foo() {
        console.log("Привет от Родителя!");
    }
}

var child = {
    foo() {
        super.foo();
        console.log("Привет от Ребёнка!");
    }
}

Object.setPrototypeOf(child, parent);
child.foo(); // Привет от Родителя!
             // Привет от Ребёнка!
```

---

## 9) Шаблонные строки
ES6 предоставяляет более простой способ вставки значения переменной или результата выражения (т.н. "интерполяцию"), которые рассчитываются автоматически.
- `${ ... }` используется для вычисления значения переменной/выражения.
- `` Обратные кавычки используются как разделитель для таких случаев.
```js
let user = 'Кевин';
console.log(`Привет, ${user}!`); // Привет, Кевин!
```

---

## 10) for...of и for...in
- `for...of` используется для перебора в цикле итерируемых объектов, например, массивов.
- `for...in` используется для перебора в цикле всех доступных для перебора (enumerable) свойств объекта.
```js
const array = ['a', 'b', 'c'];
for(let item in array) {
  console.log(item); // 0 1 2
}

for(let item of array) {
  console.log(item); // a b c
}
```

```js
const obj = {
  k1: 'a',
  k2: 'b',
  k3: 'c',
};
for(let item in obj) {
  console.log(item); // k1 k2 k3
}

// ошибка так как object не итерируемый
// Если бы «базовый класс» Object был итерируемым, то и любой «подкласс» Function/Date/etc среди прочих осложнений был бы итерируемым. 
for(let item of obj) {
  console.log(item); // a b c
}
```

---

## 11) Map и WeakMap
ES6 представляет новые структуры данных — `Map` и `WeakMap`. На самом деле, мы используем "Map" в JavaScript всё время. Каждый объект можно представить как частный случай Map.

### Map

Классический объект состоит из ключей (всегда в строковом виде) и значений, тогда как в `Map` для ключа и значения можно использовать любое значение (и объекты, и примитивы).
```js
var myMap = new Map();

var keyString = "строка",
    keyObj = {},
    keyFunc = function() {};

// устанавливаем значения
myMap.set(keyString, "значение, связанное со 'строка'");
myMap.set(keyObj, "значение, связанное с keyObj");
myMap.set(keyFunc, "значение, связанное с keyFunc");

myMap.size; // 3

// получаем значения
myMap.get(keyString);    // "значение, связанное со 'строка'"
myMap.get(keyObj);       // "значение, связанное с keyObj"
myMap.get(keyFunc);      // "значение, связанное с keyFunc"
```

#### Методы и свойства:
- `new Map()` – создаёт коллекцию.
- `map.set(key, value)` – записывает по ключу key значение value.
- `map.get(key)` – возвращает значение по ключу или undefined, если ключ key
отсутствует.
- `map.has(key)` – возвращает true, если ключ key присутствует в коллекции, иначе
false.
- `map.delete(key)` – удаляет элемент по ключу key. map.clear() – очищает коллекцию от всех элементов. map.size – возвращает текущее количество элементов.

#### Перебор Map
- `map.keys()` – возвращает итерируемый объект по ключам,
- `map.values()` – возвращает итерируемый объект по значениям,
- `map.entries()` – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.
- `map.forEach((value, key, map)` - немного отличаются параметры с в сравнении с array

### WeakMap

`WeakMap` это `Map`, в котором ключи обладают неустойчивыми связями, что позволяет не мешать сборщику мусора удалять элементы `WeakMap`. Это означает, что можно не беспокоиться об утечках памяти.


Стоить отметить, что в `WeakMap`, в отличие от `Map`, каждый ключ должен быть объектом.


Для `WeakMap` есть только четыре метода: `delete(ключ)`, `has(ключ)`, `get(ключ)` и `set(ключ, значение)`.
```js
let w = new WeakMap();
w.set('a', 'b');
// Uncaught TypeError: Invalid value used as weak map key

var o1 = {},
    o2 = function(){},
    o3 = window;

w.set(o1, 37);
w.set(o2, "azerty");
w.set(o3, undefined);

w.get(o3); // undefined, потому что это заданное значение

w.has(o1); // true
w.delete(o1);
w.has(o1); // false
```

---

## 12) Set и WeakSet

### Set

Объекты Set это коллекции уникальных значений. Дублированные значения игнорируются, т.к. коллекция должна содержать только уникальные значения. Значения могут быть примитивами или ссылками на объекты.

```js
let mySet = new Set([1, 1, 2, 2, 3, 3]);
mySet.size; // 3
mySet.has(1); // true
mySet.add('строки');
mySet.add({ a: 1, b:2 });
```

Вы можете перебирать `Set` в цикле с помощью `forEach` или `for...of`. Перебор происходит в том же порядке, что и вставка.
```js
mySet.forEach((item) => {
    console.log(item);
    // 1
    // 2
    // 3
    // 'строки'
    // Object { a: 1, b: 2 }
});

for (let value of mySet) {
    console.log(value);
    // 1
    // 2
    // 3
    // 'строки'
    // Object { a: 1, b: 2 }
}
```
#### Основные методы:
- `new Set(iterable)` – создаёт `Set`, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый `Set`.
- `set.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
- `set.delete(value)` – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
- `set.has(value)` – возвращает true, если значение присутствует в множестве, иначе false.
- `set.clear()` – удаляет все имеющиеся значения.
- `set.size` – возвращает количество элементов в множестве.
- `set.values()` – возвращает перебираемый объект для значений,
- `set.keys()` – то же самое, что и `set.values()` , присутствует для обратной - совместимости с `Map`,
- `set.entries()` – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.
- `set.forEach((value, valueAgain, set)` - где `value` и `valueAgain` одно и тоже значение. Это сделано для совместимости с `Map`

### WeakSet

Аналогично `WeakMap`, объект `WeakSet` позволяет хранить объекты с неустойчивыми связями в коллекции. Объект в `WeakSet` уникален.

```js
var ws = new WeakSet();
var obj = {};
var foo = {};

ws.add(window);
ws.add(obj);

ws.has(window); // true
ws.has(foo);    // false, foo не был добавлен к коллекции

ws.delete(window); // удаляет window из коллекции
ws.has(window);    // false, window был удалён
```

---

## 13) Классы
#### [Классовое наследование](../../oop/class/REAdME.md)

---

## 14) Тип данных Symbol
`Symbol` это уникальный и неизменяемый тип данных, представленный в ES6. Целью `Symbol` является создание уникального идентификатора, к которому нельзя получить доступ.
```js
var sym = Symbol("опциональное описание"); // без new
console.log(typeof sym); // symbol
```

Если `Symbol` используется как свойство/ключ объекта, он сохраняется таким специальным образом, что свойство не будет показано при нормальном перечислении свойств объекта.
Чтобы извлечь символьные свойства объекта, нужно использовать `Object.getOwnPropertySymbols(o)`
```js
var o = {
  val: 10,
  [Symbol("случайный")]: "Я - символ",
};

console.log(Object.getOwnPropertyNames(o)); // [val]
console.log(Object.getOwnPropertySymbols(o)); // [Symbol(случайный)]
```

### Основные характеристики типа `Symbol`:
- уникальность
- неизменяемость
- неявная конвертация в строку
При использовании символа в контексте, где требуется строка (например, при конкатенации с помощью `+` или в шаблонных строках), JavaScript автоматически вызывает `.toString()`
- не используется для обычной сериализации объектов и игнорируются при обычной итерации

### Глобальные символы

#### `Symbol.for`

Итак, как мы видели, обычно все символы уникальны, даже если их имена совпадают. Но иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью. Например, разные части нашего приложения хотят получить доступ к символу `"id"`, подразумевая именно одно и то же свойство.

Для этого существует глобальный реестр символов. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.

Для чтения (или, при отсутствии, создания) символа из реестра используется вызов `Symbol.for(key)`.

Он проверяет глобальный реестр и, при наличии в нём символа с именем `key`, возвращает его, иначе же создаётся новый символ `Symbol(key)` и записывается в реестр под ключом `key`.
```js
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true
```

#### `Symbol.keyFor`
Для глобальных символов, кроме `Symbol.for(key)`, который ищет символ по имени, существует обратный метод: `Symbol.keyFor(sym)`, который, наоборот, принимает глобальный символ и возвращает его имя.
```js
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
```

---

## 15) Итераторы
Итератор обращается к элементам коллекции по одному, в то же время сохраняя память о своей текущей позиции в этой коллекции. У итератора есть метод `next()`, который возвращает следующий элемент в последовательности. Этот метод возвращает объект с двумя свойствами: `done` (окончен ли перебор) и `value` (значение).

В ES6 есть метод `Symbol.iterator`, который определяет итератор для объекта по-умолчанию. При каждой необходимости перебора в цикле для объекта (например, в начале цикла for..of), его метод итератора вызывается без аргументов, и возвращённый итератор используется для того, чтобы получить значения для перебора.


Посмотрим на массив, который является перебираемым (iterable), и на итератор, который есть у массива для обработки его значений:
```js
var arr = [11,12,13];
var itr = arr[Symbol.iterator]();

itr.next(); // { value: 11, done: false }
itr.next(); // { value: 12, done: false }
itr.next(); // { value: 13, done: false }

itr.next(); // { value: undefined, done: true }
```

[Подробнее про итераторы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Iteration_protocols)

---

## 16) Генераторы
Функции-генераторы представляют собой новую особенность ES6, которая позволяет функции создавать много значений в течение некоторого периода времени, возвращая объект (называемый генератором), который может быть итерирован для выброса значений из функции по одному за раз.


Функция-генератор возвращает итерируемый объект при своём вызове.
Функция-генератор записывается с помощью знака `*` после ключевого слова `function`, а в теле функции должно присутствовать ключевое слово `yield`
Каждый раз при вызове `yield` возвращённое значение становится следующим значением в последовательности.
```js
function *infiniteNumbers() {
    var n = 1;
    while (true) {
        yield n++;
    }
}

var numbers = infiniteNumbers(); // возвращает перебираемый объект

numbers.next(); // { value: 1, done: false }
numbers.next(); // { value: 2, done: false }
numbers.next(); // { value: 3, done: false }
```

---

## 17) Промисы
В ES6 появилась встроенная поддержка промисов. Промис это объект, который ждёт выполнения асинхронной операции, после которого (т.е. после выполнения) промис принимает одно из двух состояний: `fulfilled` (resolved, успешное выполнение) или `rejected` (выполнено с ошибкой).

`Promise` может находиться в трёх состояниях:

ожидание (`pending`): начальное состояние, не исполнен и не отклонён.
исполнено (`fulfilled`): операция завершена успешно.
отклонено (`rejected`): операция завершена с ошибкой.

~~Продолжение следует~~

---